// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robots.subsystems;


import frc.robots.RobotMap;
import frc.robots.commands.*;
import frc.robots.subsystems.TalonSubsystem.TalonConfiguration;
import frc.robots.talonpidconstants.DriveTrainMotionMagicConstants;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.Faults;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRXConfiguration;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveTrain extends Subsystem {

    

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static final double 
        MAX_DRIVE_SPEED = 0.75,
        MIN_DRIVE_SPEED = 0.1;


    private WPI_VictorSPX leftDriveVictor;
    private WPI_VictorSPX rightDriveVictor;
    private WPI_TalonSRX leftDriveTalon;
    private WPI_TalonSRX rightDriveTalon;
    private DifferentialDrive drive;
    private Faults _leftDriveFaults;
    private Faults _rightDriveFaults;
    private TalonConfiguration driveTrainConfig;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public DriveTrain() {
        var error = 0;
        leftDriveTalon = new WPI_TalonSRX(RobotMap.LEFT_DRIVE_TALON_CAN_ID);
        // leftDriveTalon.set(ControlMode.PercentOutput, 0);
        error |= leftDriveTalon.configFactoryDefault().value;
        leftDriveTalon.setNeutralMode(NeutralMode.Brake);
        error |= leftDriveTalon.configVoltageCompSaturation(10.0).value;
        leftDriveTalon.enableVoltageCompensation(true);

        leftDriveTalon.configOpenloopRamp(0.5);
        leftDriveTalon.setSensorPhase(true);
        leftDriveTalon.setInverted(false);

        
        leftDriveVictor = new WPI_VictorSPX(RobotMap.LEFT_DRIVE_VICTOR_CAN_ID);
        leftDriveVictor.follow(leftDriveTalon);
        
        rightDriveTalon = new WPI_TalonSRX(RobotMap.RIGHT_DRIVE_TALON_CAN_ID);
        // rightDriveTalon.set(ControlMode.PercentOutput, 0);
        rightDriveTalon.configFactoryDefault();
        rightDriveTalon.setNeutralMode(NeutralMode.Brake);
        rightDriveTalon.configVoltageCompSaturation(10.0);
        rightDriveTalon.enableVoltageCompensation(true);
        rightDriveTalon.configOpenloopRamp(0.5);
        rightDriveTalon.setSensorPhase(true);
        rightDriveTalon.setInverted(false);

        driveTrainConfig = new TalonConfiguration(DriveTrainMotionMagicConstants.PRIMARY_GAINS, DriveTrainMotionMagicConstants.AUXILLARY_GAINS);
        TalonSubsystem.configureDriveTrainTalons(leftDriveTalon, rightDriveTalon, driveTrainConfig, FeedbackDevice.CTRE_MagEncoder_Relative);
        TalonSubsystem.configureNominalAndPeakOutputs(leftDriveTalon, driveTrainConfig, 0, 0, +1.0, -1.0);
        TalonSubsystem.configureNominalAndPeakOutputs(rightDriveTalon, driveTrainConfig, 0, 0, +1.0, -1.0);
        TalonSubsystem.configureMotionMagicValues(rightDriveTalon, driveTrainConfig, DriveTrainMotionMagicConstants.CRUISE_VELOCITY, DriveTrainMotionMagicConstants.ACCELERATION);
        TalonSubsystem.zeroSensor(rightDriveTalon, driveTrainConfig); 
        TalonSubsystem.zeroSensor(leftDriveTalon, driveTrainConfig);  

        rightDriveVictor = new WPI_VictorSPX(RobotMap.RIGHT_DRIVE_VICTOR_CAN_ID);
        rightDriveVictor.follow(rightDriveTalon);


        // TalonSubsystem.configureDriveTrainTalons(leftDriveTalon, rightDriveTalon, config, primaryDevice);

        
        
        
        
        // drive = new DifferentialDrive(leftDriveTalon, rightDriveTalon);
        // addChild("Differential Drive 1",drive);
        // drive.setSafetyEnabled(true);
        // drive.setExpiration(0.1);
        // drive.setMaxOutput(1.0);

        _leftDriveFaults = new Faults();
        _rightDriveFaults = new Faults();

       if (error != 0) {
           System.out.print("Error configuring Talons for Drive Train");
           // ...
       }
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        this.setDefaultCommand(new DriveCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // public void curveDrive(double speed, double rotation, boolean isQuickTurn) {
    //     drive.curvatureDrive(speed, rotation, isQuickTurn);
    // }

    public ErrorCode getLeftDriveTalonFaults() {
        return leftDriveTalon.getFaults(_leftDriveFaults);
    }

    public void printLeftDriveTalonValues() {
        TalonSubsystem.printTalonOutputs(leftDriveTalon);
    }

    public ErrorCode getRightDriveTalonFaults() {
        return rightDriveTalon.getFaults(_rightDriveFaults);
    }

    public void printRightDriveTalonValues() {
        TalonSubsystem.printTalonOutputs(rightDriveTalon);
    }

    public void setArcadeDrive(double joyForward, double joyTurn) {
        double rightForward;
        double leftForward;
        // if(Math.abs(joyTurn) > 0.4) {
        //     joyTurn = 0.4 * joyTurn;
        // }

        rightForward = -joyForward;
        leftForward = +joyForward;

        // if(Math.abs(joyForward) < 0.1 && joyTurn < 0.1) {
        //     rightForward = -0.0;
        //     leftForward = +joyForward;
        // } else if(Math.abs(joyForward) < 0.1 && joyTurn > 0.1) {
        //     leftForward = 0.0;
        //     rightForward = -joyForward;
        // } else {
        //     rightForward = -joyForward;
        //     leftForward = +joyForward;
        // }
        leftDriveTalon.set(ControlMode.PercentOutput, leftForward, DemandType.ArbitraryFeedForward, joyTurn);
	 	rightDriveTalon.set(ControlMode.PercentOutput, rightForward, DemandType.ArbitraryFeedForward, joyTurn);
    }

    public void driveStraight(double joyForward) {
        double rightForward;
        double leftForward;
        rightForward = -joyForward;
        leftForward = +joyForward;

        leftDriveTalon.set(ControlMode.PercentOutput, leftForward, DemandType.ArbitraryFeedForward, 0);
	 	rightDriveTalon.set(ControlMode.PercentOutput, rightForward, DemandType.ArbitraryFeedForward, 0);
    }

    public void setProfileSlotsDriveTrain() {
        rightDriveTalon.selectProfileSlot(0, 0);
        rightDriveTalon.selectProfileSlot(1, 1);
    }
    

    


    


}

